\section{Технологический раздел}

% NOTE:
% Технологический раздел содержит обоснованный выбор средств программной реализации, описание основных (нетривиальных) моментов разработки и методики тестирования созданного ПО
% В этом же разделе описывается информация, необходимая для сборки и запуска разработанного ПО, форматы входных, выходных и конфигурационных файлов (если они имеются), а также интерфейс пользователя и руководство пользователя
% Часть технологического раздела должна быть посвящена тестированию разработанного ПО
% Модульное тестирование описывается в технологическом разделе
% Системное тестирование может быть описано в технологическом или исследовательском разделах

% Рек. Объем 20-25 страниц

\subsection{Выбор средств реализации}

Для реализации метода выделения составных частей научного текста на основе анализа распределения пикселей в сканирующей строке был выбран Python~\cite{python} по следующим причинам:
\begin{itemize}
    \item язык программирования позволяет быстро создавать рабочие прототипы в связи с наличием большого количества библиотек;
    \item имеются библиотеки для работы с PDF документами и изображениями;
    \item есть опыт работы с данным языком программирования.
\end{itemize}

Для управления зависимостями Python-проекта и организации изолированных виртуальных окружений, обеспечивая воспроизводимость и независимость среды выполнения, был выбран uv~\cite{uv}.

Для работы с массивами данных (в том числе сканирующей строкой пикселей) была выбрана библиотека NumPy~\cite{numpy}.

Для работы с изображениями и PDF были выбраны библиотеки PIL~\cite{pil} и PyMuPDF~\cite{pymupdf} соответственно, так как в процессе работы программы используются как PDF документы, так и изображения, а PyMuPDF позволяет преобразовывать результат рендеринга PDF в формат, поддерживаемый PIL, который, в свою очередь, может быть преобразован в NumPy массив и использован для дальнейшей обработки.

Для создания веб-интерфейса была выбрана библиотека Gradio~\cite{gradio}, так как данная библиотека позволяет быстро создать рабочий прототип графического интерфейса к программе.

В качестве среды разработки был выбран Neovim~\cite{nvim} по следующим причинам:
\begin{itemize}
    \item данный текстовый редактор позволяет редактировать файлы с исходным кодом программы;
    \item быстрая и удобная навигация по файлам проекта;
    \item есть опыт использования данного текстового редактора.
\end{itemize}

% Обосновать выбор программных средств реализации предложенного метода

\subsection{Реализация программного обеспечения}

% Описать формат входных и выходных данных

\subsection{Результаты тестирования}

% Реализовать предложенный метод
После разработки программного обеспечения было проведено тестирование модуля разметки.
Тестирование проводилось в соответствии с описанными в конструкторском разделе классами эквивалентности.
При тестировании уточненной разметки классы эквивалентности были объединены в более крупные --- на основе получаемого класса разметки на выходе.
Результаты тестирования представлены в листинге \ref{lst:test} ниже.

\begin{lstlisting}[caption={Результаты тестирования}, label={lst:test}]
======== short test summary info ================
PASSED test.py::TestPrimaryMarkup::test_background
PASSED test.py::TestPrimaryMarkup::test_few_text
PASSED test.py::TestPrimaryMarkup::test_undefined
PASSED test.py::TestPrimaryMarkup::test_many_text
PASSED test.py::TestPrimaryMarkup::test_long_black_line
PASSED test.py::TestPrimaryMarkup::test_medium_black_line
PASSED test.py::TestPrimaryMarkup::test_color
PASSED test.py::TestSpecifiedMarkup::test_to_text
PASSED test.py::TestSpecifiedMarkup::test_to_table
PASSED test.py::TestSpecifiedMarkup::test_to_code
PASSED test.py::TestSpecifiedMarkup::test_to_diagram
PASSED test.py::TestSpecifiedMarkup::test_to_figure
PASSED test.py::TestSpecifiedMarkup::test_to_plot
PASSED test.py::TestSpecifiedMarkup::test_to_undefined
PASSED test.py::TestMergedMarkup::test_merge_little_bg
PASSED test.py::TestMergedMarkup::test_merge_bg_interpolate
PASSED test.py::TestMergedMarkup::test_swap_bg_to_undefined
PASSED test.py::TestMergedMarkup::test_merge_undefined
PASSED test.py::TestMergedMarkup::test_merge_segments
\end{lstlisting}

\newpage

\subsection{Пользовательский интерфейс}

% Описать взаимодействие пользователя с программным обеспечением

На рисунках \ref{fig:webstart} -- \ref{fig:webdone} ниже представлен порядок взаимодействия пользователя с графическим веб-интерфейсом.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/web-start.png}
    \caption{Выбор типа разметки}
	\label{fig:webstart}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/web-process.png}
    \caption{Разметка в процессе}
	\label{fig:webproc}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/web-done.png}
    \caption{Разметка завершена --- пользователь может скачать разметку в формате JSON и/или PDF документ для ее визуализации}
	\label{fig:webdone}
\end{figure}

\newpage

\subsection{Демонстрация работы программы}

На рисунках \ref{fig:line} -- \ref{fig:merged} ниже приведена демонстрация работы программы.
Представлены результаты построчной (строке пикселей назначется класс на основе распределения пикселей в ней, без использования конечного автомата), первичной, уточненной и объединенной разметок.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/m.line.png}
    \caption{Пример построчной разметки}
	\label{fig:line}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/m.prim.png}
    \caption{Пример первичной разметки}
	\label{fig:prim}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/m.spec.png}
    \caption{Пример уточненной разметки}
	\label{fig:spec}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/m.merged.png}
    \caption{Пример объединенной разметки}
	\label{fig:merged}
\end{figure}

\newpage

В листингах \ref{lst:main} и \ref{lst:apply} ниже представлен результат работы программы при запуске из терминала.

Для запуска программы требуется установить uv командой:
\begin{lstlisting}[caption={Запуск и результат работы разметки из терминала}, label={lst:main}]
uv run main.py ~/index.pdf x.json 3
Pages processed: 31/31 [00:06<00:00,  5.11it/s]
\end{lstlisting}

\begin{lstlisting}[caption={Запуск и результат применения разметки к PDF из терминала}, label={lst:apply}]
uv run apply.py ~/index.pdf x.json output.pdf
Annotating pages: 31/31 [00:00<00:00, 383.41it/s]
Сохранено в: output.pdf
\end{lstlisting}

\subsection{Руководство пользователя}

Для запуска программы требуется установить uv командой:
\begin{lstlisting}[caption={Установка uv}]
curl -LsSf https://astral.sh/uv/install.sh | sh
\end{lstlisting}

После установки uv, следует установить зависимости приложения.
Для этого, находясь в директории с программой, следует прописать команду:
\begin{lstlisting}[caption={Установка зависимостей}]
uv sync
\end{lstlisting}

Графический интерфейс запускается локально командой:
\begin{lstlisting}[caption={Запуск графического веб-интерфейса}]
uv run webgui.py
\end{lstlisting}

Также можно создать разметку без использования графического интерфейса.
Для этого используется скрипт main.py:
\begin{lstlisting}[caption={Запуск скрипта для создания разметки}]
Использование: main.py [-w КОЛИЧЕСТВО_ПРОЦЕССОВ]
                       [-p СТРАНИЦЫ]
                       pdf_path json_path {0,1,2,3}

Сегментировать PDF страницы и экспортировать разметку в JSON.

Позиционные аргументы:
  pdf_path              Путь ко входному PDF файлу
  json_path             Путь к выходному JSON файлу
  {0,1,2,3}             Тип разметки: 0 - построчная разметка,
                                      1 - первичная разметка,
                                      2 - уточненная разметка,
                                      3 - объединенная разметка

Опции:
  -w, --workers КОЛИЧЕСТВО_ПРОЦЕССОВ
                        Количество рабочих процессов
                        (по умолчанию: 8)
  -p, --pages СТРАНИЦЫ  Диапазоны страниц для обработки,
                        например, '1-3,5,7-9'
\end{lstlisting}

Для применения разметки к документу без графического интерфейса используется скрипт apply.py:
\begin{lstlisting}[caption={Запуск скрипта для применения разметки к PDF документу}]
Использование: apply.py [-h] pdf_path json_path output_path

Разметить PDF цветными сегментами из JSON файла разметки.

Позиционные аргументы:
  pdf_path     Путь ко входному PDF файлу
  json_path    Путь к JSON файлу с разметкой
  output_path  Путь для сохранения размеченного PDF
\end{lstlisting}

\subsection*{Вывод}

% \section{Функциональное тестирование}
%
% В ходе работы программы, создаются три разметки:
% \begin{enumerate}
%     \item Первичная разметка --- сегмент текста классифицируется на основе анализа распределения пикселей в смежных строках, и переходов состояний в конечном автомате. Размеченный сегмент получает класс в соответствии с последним состоянием, в котором он находился. Буквально класс равен последнему состоянию.
%     \item Уточненная разметка --- класс сегмента уточняется на основе признаков самого сегмента целиком (таких как размер, количество сплошных черных участков, количество цветных строк, тепловая карта черных пикселей и т.д.). В результате сегмент получает конечный класс (Фон, Текст, Таблица, Листинг, Рисунок, График, Схема и т.д.).
%     \item Объединение сегментов --- сегменты объединяются по определенным правилам, например, небольшой фоновый или неопределенный сегмент сливается с наибольшим соседним.
% \end{enumerate}
%
% В связи с чем для проверки работоспособности программы нужно проверять корректность разметки, сформированной в конце каждого этапа отдельно для лучшей локализации возможных ошибок.
%
% % Далее будет более подробно рассмотрено тестирование программы на каждом из этапов.
% Далее будет более подробно рассмотрено тестирование программы на этапе первичной разметки.
%
% \newpage
%
% \subsection{Тестирование первичной разметки}
%
% Первичная разметка зависит от двух факторов:
% \begin{enumerate}
%     \item Точность классификации отдельной строки пикселей;
%     \item Корректность работы конечного автомата состояний.
% \end{enumerate}
%
% Таким образом, ошибка в первичной разметке сводится к некорректной классификации строки сегмента и/или некорректной работе конечного автомата состояний.
%
% Точность классификации отдельной строки пикселей зависит от:
% \begin{itemize}
%     \item Корректности правил классификации строки на основе анализа распределения пикселей в ней;
%     \item Внутренних настраиваемых параметров (например, какую строку черных пикселей считать большой или средней длины, или какие расстояния между кластерами не фоновых пикселей считать маленькими, а какие большими).
% \end{itemize}
%
% Корректность работы конечного автомата состояний зависит от корректности таблицы переходов его состояний.
%
% Правила классификации строк, значения параметров и таблица переходов состояний конечного автомата задаются либо <<на глаз>> (параметр изменяется пока разметка не станет визуально корректной), либо исходя из логических соображений (например, если в строке много черных и белых переходов, вероятно это текст, или если на предыдущем этапе сегмент был классифицирован как <<Немного текста>>, а текущая строка как <<Много текста>>, то вероятно сегмент относится к классу <<Много текста>>).
%
% Следовательно, так как работа алгоритма зависит исключительно от интуитивно подобранных правил и значений, то и корректность его работы можно оценить тоже только <<на глаз>>, например, сравнивая разметку с эталонной.
%
% % \begin{figure}[H]
% % 	\centering
% % 	\includegraphics[width=0.5\textwidth]{diag/fsm.pdf}
% % 	\caption{Конечный автомат состояний.
% %     FEW $\equiv$ <<Немного текста>>,
% %     UNDEF $\equiv$ <<Неопределено>>,
% %     MANY $\equiv$ <<Много текста>>,
% %     MBL $\equiv$ <<Средняя черная строка>>,
% %     LBL $\equiv$ <<Длинная черная строка>>,
% %     COLOR $\equiv$ <<Цвет>>}
% % 	\label{fig:fsm}
% % \end{figure}
%
% \subsubsection{Алгоритм тестирования}
%
% На рисунке ниже приведен пример алгоритма сравнения разметки с эталонной.
%
% \begin{figure}[H]
% 	\centering
% 	\includegraphics[width=\textwidth]{diag/vkr-test-primary.pdf}
%     \caption{Алгоритм сравнения разметки с эталонной}
% 	\label{fig:}
% \end{figure}
%
% \subsubsection{Классы эквивалентности}
%
% Классы эквивалентности естественным образом соответствуют классам первичной разметки:
% \begin{itemize}
%     \item Фон;
%     \item Неопределенность;
%     \item Много текста;
%     \item Мало текста;
%     \item Большая черная линия;
%     \item Небольшая черная линия;
%     \item Цвет.
% \end{itemize}
%
% Для тестирования разметки Фона можно предложить следующие тестовые сценарии:
% \begin{itemize}
%     \item Белая строка высотой в один пиксель;
%     \item Больше одной фоновой строки подряд;
%     \item Пустая страница.
% \end{itemize}
%
% Для тестирования вывода состояния <<Много текста>> можно предложить следующие тестовые сценарии:
% \begin{itemize}
%     \item Строка текста на русском языке;
%     \item Строка текста на английском языке;
%     \item Строка текста на китайском языке;
%     \item Строка текста длиной во всю ширину документа;
%     \item Строка текста длиной больше половины документа.
% \end{itemize}
%
% Для тестирования вывода состояния <<Мало текста>> можно предложить следующие тестовые сценарии:
% \begin{itemize}
%     \item Текст <<Мало текста>>;
%     \item Текст <<аа>>;
%     \item Строка текста длиной меньше половины документа.
% \end{itemize}
%
% Для тестирования вывода состояния <<Большая черная строка>> можно предложить следующие тестовые сценарии:
% \begin{itemize}
%     \item Большая черная строка высотой в один пиксель;
%     \item Большая черная строка высотой в несколько пикселей;
%     \item Листинг кода;
%     \item Таблица;
%     \item Черно-белое изображение в рамке.
% \end{itemize}
%
% Для тестирования вывода состояния <<Небольшая черная строка>> можно предложить следующие тестовые сценарии:
% \begin{itemize}
%     \item Небольшая черная линия;
%     \item Подчеркнутый текст;
%     \item Блок схемы алгоритма;
%     \item Схема алгоритма.
% \end{itemize}
%
% Для тестирования вывода состояния <<Цвет>> можно предложить следующие тестовые сценарии:
% \begin{itemize}
%     \item Цветное изображение без рамки;
%     \item Цветной текст;
%     \item Цветной текст внутри не цветного.
% \end{itemize}
%
% Для тестирования вывода состояния <<Неопределенность>> (состояние, в котором не удалось причислить сегмент ни к одному из состояний) можно предложить следующие тестовые сценарии:
% \begin{itemize}
%     \item Граф сверточной нейронной сети без прямых линий;
%     \item Черно-белое изображение без прямых черных линий.
% \end{itemize}
%
% \subsubsection{Результаты тестирования}
% % Листинги кода, входные данные и результаты тестирования, позитивные и негативные
% % Write some code, write some test, make it fail, make it pass
%
% Эталонная разметка, учитывающая описанные ранее сценарии тестирования, приведена в приложении.
% Цвета разметки соотносятся с классами разметки следующим образом:
% \begin{itemize}
%     \item Маджента --- <<Много текста>>;
%     \item Желтый --- <<Неопределенность>>;
%     \item Зеленый --- <<Мало текста>>;
%     \item Синий --- <<Большая черная линия>>;
%     \item Красный --- <<Небольшая черная линия>>;
%     \item Циан --- <<Рисунок>>.
% \end{itemize}
%
% Ниже приведен код для сравнения разметки с эталонной.
% Разметка представляет собой массив кортежей из трех элементов: начало сегмента, конец сегмента и класс.
%
% \begin{lstlisting}[caption={Сравнение разметки с эталонной}]
% def expand_segments(segments, height, default):
%     result = [default] * height
%     for y0, y1, cls in segments:
%         if y0 < 0 or y1 >= height:
%             raise ValueError(f"Сегмент ({y0},{y1}) выходит за границы [0, {height-1}]")
%         for y in range(y0, y1 + 1):
%             result[y] = cls
%     return result
%
% def compare_segments(markup_segs, etalon_segs, height):
%     markup = expand_segments(markup_segs, height, default)
%     etalon = expand_segments(etalon_segs, height, default)
%     match = 0
%     wrong = []
%     for i in range(height):
%         if markup[i] == etalon[i]:
%             match += 1
%         else:
%             wrong.append(i)
%     if match == height:
%         print("Разметки совпадают")
%         return True, wrong
%     else:
%         print(f"Разметки не совпадают, найдено {len(wrong)} несоответствий")
%         return False, wrong
% \end{lstlisting}
%
